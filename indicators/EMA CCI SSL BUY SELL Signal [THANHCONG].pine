//@version=5
indicator(title="EMA CCI SSL BUY SELL Signal [THANHCONG]", overlay=true)

// === HTF Settings ===
mode = input.string(title='HTF Method', defval='Auto', options=['Auto', 'Manual'], group='SSL Channel')
HTF_manual = input.timeframe('240', title='HTF (Manual only)', group='SSL Channel')

// Auto HTF logic
HTF_auto = timeframe.period == '5'   ? '60'  :
           timeframe.period == '15'  ? '60'  :
           timeframe.period == '30'  ? '60'  :
           timeframe.period == '60'  ? '120' :
           timeframe.period == '120' ? '240' :
           timeframe.period == '240' ? '480' :
           timeframe.period == '360' ? '1D'  :
           timeframe.period == '480' ? '1D'  :
           timeframe.period == '720' ? '1D'  :
           timeframe.period == 'D'   ? '3D'  :
           timeframe.period == '3'   ? 'W'   : '5W'

HTF = mode == 'Auto' ? HTF_auto : HTF_manual

// === SSL Channel from HTF ===
[h, l, c] = request.security(syminfo.tickerid, HTF, [high, low, close], gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)
smaHigh = ta.sma(h, 8)
smaLow  = ta.sma(l, 8)
Hlv = float(na)
Hlv := c > smaHigh ? 1 : c < smaLow ? -1 : Hlv[1]
sslDown = Hlv < 0 ? smaHigh : smaLow
sslUp   = Hlv < 0 ? smaLow  : smaHigh
// === RSI Filter ===
rsi = ta.rsi(close, 14)
rsiOverbought = 70
rsiOversold = 30
rsi_filter_buy = rsi < rsiOversold
rsi_filter_sell = rsi > rsiOverbought
// === CCI Settings ===
cciTurboLength = input.int(6, title="CCI Turbo Length", minval=3, maxval=14)
cci14Length    = input.int(14, title="CCI 14 Length", minval=7, maxval=20)

cciTurbo = ta.cci(close, cciTurboLength)
cci14    = ta.cci(close, cci14Length)

// === Volume Spike Filter ===
vol_ma = ta.sma(volume, 20)
vol_spike = volume > vol_ma * 1.5
// === CCI Divergence (Simplified) ===
bullish_div = (close < close[1]) and (cciTurbo > cciTurbo[1])
bearish_div = (close > close[1]) and (cciTurbo < cciTurbo[1])

// === Candlestick Reversal Patterns ===
// Hammer (bottom): small body, long lower wick
hammer = (close > open) and ((open - low) > 2 * (close - open))

// Shooting Star (top): small body, long upper wick
shooting_star = (open > close) and ((high - open) > 2 * (open - close))

// === Final Combined Conditions ===
enhanced_buy_signal  =rsi_filter_buy and vol_spike and bullish_div and hammer
enhanced_sell_signal =rsi_filter_sell and vol_spike and bearish_div and shooting_star
// Slope calculation
slope_60 = close - close[60]
// === Entry Conditions ===
buy_condition  =slope_60 < -2 and enhanced_buy_signal and sslUp > sslDown and close > sslUp and close[1] < sslUp[1]
sell_condition =slope_60 > 2  and enhanced_sell_signal and sslUp < sslDown and close < sslUp and close[1] > sslUp[1]

// === Cross detection for entry signals (first time only) ===
var bool was_ssl_up_cross_down = na
var bool was_ssl_down_cross_up = na

ssl_up_cross_down   = ta.crossover(sslUp, sslDown)
ssl_down_cross_up   = ta.crossunder(sslUp, sslDown)

buy_signal  = ssl_up_cross_down   and not was_ssl_up_cross_down
sell_signal = ssl_down_cross_up   and not was_ssl_down_cross_up

was_ssl_up_cross_down := ssl_up_cross_down
was_ssl_down_cross_up := ssl_down_cross_up

// === Signal Labels ===
offset = (high - low) * 0.3

if buy_signal
    label.new(bar_index, low - offset, text="Buy\n" + str.tostring(close, format.mintick), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)

if sell_signal
    label.new(bar_index, high + offset, text="Sell\n" + str.tostring(close, format.mintick), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// === Live Signal Info Table ===
var table signal_info_table = table.new(position.top_right, 2, 2, border_width=1, frame_color=color.gray)
var float last_signal_price = na
var string last_signal_type = na
var color signal_bg_color = na

if buy_signal
    last_signal_price := close
    last_signal_type := "Buy"
    signal_bg_color := color.green

if sell_signal
    last_signal_price := close
    last_signal_type := "Sell"
    signal_bg_color := color.red

if not na(last_signal_price)
    // Calculate percentage change in the correct direction of the signal
    pct_change = last_signal_type == "Buy" ? ((close - last_signal_price) / last_signal_price) * 100 : ((last_signal_price - close) / last_signal_price) * 100

    // Background color based on profit/loss
    pct_change_col = pct_change >= 0 ? color.green : color.red

    // "+" or "-" sign before the percentage
    pct_change_str = pct_change >= 0 ? "+" + str.tostring(pct_change, format.percent) : str.tostring(pct_change, format.percent)

    // Update the table
    table.cell(signal_info_table, 0, 0, text=last_signal_type, bgcolor=signal_bg_color, text_color=color.white)
    table.cell(signal_info_table, 0, 1, text=str.tostring(last_signal_price, format.mintick), bgcolor=signal_bg_color, text_color=color.white)
    table.cell(signal_info_table, 1, 0, text="Change %", bgcolor=pct_change_col, text_color=color.white)
    table.cell(signal_info_table, 1, 1, text=pct_change_str, bgcolor=pct_change_col, text_color=color.white)
len = 60
devlen = 2.0
upcol = color.rgb(0, 138, 71)
dncol = color.rgb(124, 1, 1)
widt = 2
extendit = false  // tắt extend.right vì ta sẽ tự mở rộng bằng x1,x2

get_channel(src, len) =>
    mid = ta.sma(src, len)
    slope = ta.linreg(src, len, 0) - ta.linreg(src, len, 1)
    intercept = mid - slope * math.floor(len / 2) + ((1 - (len % 2)) / 2) * slope
    endy = intercept + slope * (len - 1)
    dev = 0.0
    for x = 0 to len - 1
        dev += math.pow(src[x] - (slope * (len - x) + intercept), 2)
    dev := math.sqrt(dev / len)
    [intercept, endy, dev, slope]

[y1, y2, dev, slope] = get_channel(close, len)
col = slope >= 0 ? upcol : dncol

var line[] reglines = array.new_line(3)
if barstate.isfirst
    for i = 0 to 2
        array.push(reglines, na)

for x = 0 to 2
    y_start = y1 + devlen * dev * (x - 1)
    y_end = y2 + devlen * dev * (x - 1)
    
    x1 = bar_index - len + 1 - 10  // kéo dài thêm 10 cây nến về phía trước
    x2 = bar_index
    
    if not na(array.get(reglines, x))
        line.set_xy1(array.get(reglines, x), x1, y_start)
        line.set_xy2(array.get(reglines, x), x2, y_end)
        line.set_color(array.get(reglines, x), col)
        line.set_width(array.get(reglines, x), widt)
        line.set_style(array.get(reglines, x), x == 1 ? line.style_solid : line.style_dashed)
        line.set_extend(array.get(reglines, x), extend.none)  // tắt extend
    else
        array.set(reglines, x, line.new( x1 = x1, y1 = y_start, x2 = x2, y2 = y_end, color = col, width = widt, style = x == 1 ? line.style_solid : line.style_dashed, extend = extend.none))
